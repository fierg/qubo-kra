import logging

import classes.node as node
from collections import defaultdict


# This class provides autility to generate a graph and compute strongly connected components on it.
# The SCC's are generated by the algorithm described in
# https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm as of 2022-08-06.
class Graph:

    def __init__(self, vertices):
        self.V = len(vertices)
        # No. of vertices
        self.vertices = vertices
        self.nodes = defaultdict(list)
        for vertex in vertices:
            self.nodes[vertex] = node.node()
        self.index = 0
        self.stack = []
        self.graph = defaultdict(list)  # default dictionary to store graph
        self.generated = False
        self.components = []
        self.final_components = []

    # function to add an edge to graph
    def add_edge(self, u, v):
        if v not in self.graph[u]:
            self.graph[u].append(v)
            logging.debug("Added edge to graph: " + str(u) + ", " + str(v))

    # The main function that finds all SCC's
    def get_scc(self):
        if not self.generated:
            for node in self.vertices:
                if self.nodes[node].index == None:
                    self.strong_connect(node)
            self.generated = True

        for component in self.components:
            index = 0
            while index < len(self.final_components) and self.is_first_component_bigger(self.final_components[index], component):
                index += 1
            self.final_components.insert(index, component)

        return self.final_components

    def strong_connect(self, node):
        self.nodes[node].index = self.index
        self.nodes[node].lowlink = self.index
        self.index += 1
        self.stack.append(node)
        self.nodes[node].onstack = True

        for neighbour in self.graph[node]:
            if self.nodes[neighbour].index is None:
                self.strong_connect(neighbour)
                self.nodes[node].lowlink = min(self.nodes[node].lowlink, self.nodes[neighbour].lowlink)
            elif self.nodes[neighbour].onstack:
                self.nodes[node].lowlink = min(self.nodes[node].lowlink, self.nodes[neighbour].index)

        if self.nodes[node].lowlink == self.nodes[node].index:
            new_component = []
            current = self.stack.pop()
            while current != node:
                self.nodes[current].onstack = False
                new_component.append(current)
                current = self.stack.pop()
            self.nodes[node].onstack = False
            new_component.append(current)
            self.components.append(new_component)

    def is_first_component_bigger(self, component, comparison):
        if comparison[0] in self.graph[component[0]]:
            return True
        else:
            return False
